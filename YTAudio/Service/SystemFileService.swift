//
//  SystemFileService.swift
//  YTAudio
//
//  Created by Ion Socol on 11/10/24.
//

import UIKit
import AVFoundation
class SystemFileService {
    /**
        dir -  directory
        dirs -  directories
     
        The `PlayList` dir will be created in the Documents dir, the `PlayList` contain albums dirs. `PlayList ->
                                                                                        `Album1 ->`
                                                                                            `Audio1`
                                                                                            `Audio2`
                                                                                            `Audio3`
                                                                                        `Album2 ->`
                                                                                            `Audio1`
                                                                                            `Audio2`
        Each new created album inside`PlayList` will have its own dir, named after the album.
        Each albumâ€™s dir will contain `music files` in all audio formats supported by iOS System.
     */

    static func createAlbum(albumName: String) {
        let fileManager = FileManager.default
        guard let docURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return }
        let newAlbumDir = docURL.appendingPathComponent("PlayList").appendingPathComponent(albumName)
        ///Create new album dir
        do {
            try fileManager.createDirectory(atPath: newAlbumDir.path, withIntermediateDirectories: true)
            /// Notify the `PlayListVC` via `PlayListManager` after creating a new album dir
            NotificationCenter.default.post(name: .reloadPlayListContent, object: nil)
        } catch {
            print("\(#file) Failed create album directory \(error.localizedDescription)")
        }
    }

    static func deleteAlbum(atDir albumName: String) {
        let fileManager = FileManager.default
        if let albumDir = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent("PlayList").appendingPathComponent(albumName) {
            do {
                if fileManager.fileExists(atPath: albumDir.path) {
                    try fileManager.removeItem(at: albumDir)
                }
            } catch {
                print("Error deleting album directory \(error.localizedDescription)")
                return
            }
        } else {
            print("Failed to locate the album directory.")
        }
    }

    static func getPlayList() -> [AlbumModel] {
        let fileManager = FileManager.default
        guard let docURl = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return [] }
        let playListDir = docURl.appendingPathComponent("PlayList")

        if !fileManager.fileExists(atPath: playListDir.path) {
            do {
                /**
                    If `PlayList dir` dosen't exist it mean that i have no other album dirs inside so I create the` PlayList dir` and return an `empty array`.
                 */
                try fileManager.createDirectory(atPath: playListDir.path, withIntermediateDirectories: true)
                return []
            } catch {
                print("\(#file) Failed create Albums directory \(error.localizedDescription)")
            }
        } else {
            /// If I have `PlayList dir` already created, means that I may have some album dirs inside so i try to read content inside.
            do {
                let playListContents = try fileManager.contentsOfDirectory(atPath: playListDir.path)
                var albumsArray: [AlbumModel] = [] /// Initialize an empty array for `album dirs` in the current `PlayList` dir

                /// Iterate through `PlayList` in order to get `album dirs`
                for album in playListContents {
                    /// Check if the album has a prefix to exclude `wrong selections` such as `album` or `.DS_Store`, which is a hidden file generated by the macOS system.
                    if !album.hasPrefix(".") {
                        let currentAlbumDir = playListDir.appendingPathComponent(album) /// Get album dir
                        let currentAlbumName = currentAlbumDir.lastPathComponent /// Get album name
                        var audioArray: [AudioModel] = [] /// Init `audioArray` an empty array `to stock` audio files in the `current album dir`

                        do {
                            if try !fileManager.contentsOfDirectory(atPath: currentAlbumDir.path).isEmpty {
                                /// `audio` in for loop is just a string name of file from currentAlbumDir`
                                for audio in try fileManager.contentsOfDirectory(atPath: currentAlbumDir.path) {

                                    let audioURL = currentAlbumDir.appendingPathComponent(audio)
                                    let audio = self.processPickedAudioURL(at: audioURL)
                                    audioArray.append(audio ?? AudioModel(title: "Unknown", artist: "Unknown", duration: 0.0, url: audioURL, image: nil))
                                }

                            }
                        } catch {
                            print("Faield to get contents of \(currentAlbumName), \(error.localizedDescription)")
                        }

                        /// Apend album to albumsArray
                        albumsArray.append(AlbumModel(title: currentAlbumName, songs: audioArray, cover: nil))
                    }
                }
                print("\(#file) PlayList contents: \(albumsArray)")
                return albumsArray
            } catch {
                print("\(#file) Faield to get PlayList contents \(error.localizedDescription)")
            }
        }
        /// Return an empty array if nothing is returned for some reason. This might be a bug or an unexpected scenario, as all situations have been handled.
        return []

    }


    static func copyAudioFileToSelectedAlbum(audio: AudioModel, albumName: String) {
        print(audio, albumName)
        let fileManager = FileManager.default

        /// Access the `album dir` intended for moving the audio file.
        let pickedAlbumDir = fileManager
            .urls(for: .documentDirectory, in: .userDomainMask)
            .first!
            .appendingPathComponent("PlayList")
            .appendingPathComponent(albumName)

        /// Ensure the album directory exists
        if !fileManager.fileExists(atPath: pickedAlbumDir.path) {
            do {
                try fileManager.createDirectory(at: pickedAlbumDir, withIntermediateDirectories: true, attributes: nil)
            } catch {
                print("Error creating album directory: \(error.localizedDescription)")
                return
            }
        }

        let audioDestination = pickedAlbumDir.appendingPathComponent(audio.url.lastPathComponent)

        /// Move audio file to selected album dir
        do {
            if audio.url.startAccessingSecurityScopedResource() {
                defer {
                    audio.url.stopAccessingSecurityScopedResource()
                }
                try fileManager.copyItem(at: audio.url, to: audioDestination)
                NotificationCenter.default.post(name: .reloadPlayListContent, object: nil)
                print("Audio file moved successfully to \(audioDestination.path)")
            } else {
                print("Failed to access the file resource securely.")
            }
        } catch {
            print("Error copying audio file: \(error.localizedDescription)")
        }
    }

    ///Extract all `metaData` from audio file
    static func processPickedAudioURL(at url: URL) -> AudioModel? {

        /// Extracts the `title` from the selected audio file. If the file has no title, it is considered invalid, and the method returns `nil`.
        guard let title = url.lastPathComponent.split(separator: ".").first else {
            print("Could not extract title from file name")
            return nil
        }

        ///Create an asset for `audio metadata analysis`
        let audioAsset = AVURLAsset(url: url)

        /// Extract duration
        let duration: TimeInterval = audioAsset.duration.seconds

        /// Extract artist name (if available)
        let artist: String = audioAsset.metadata.first(where: { $0.commonKey?.rawValue == "artist" })?.value as? String ?? "Unknown"

        /// Extract the audio image (if available)
        var audioImage: UIImage?
        if let audioImageData = audioAsset.metadata.first(where: { $0.commonKey?.rawValue == "artwork" })?.value as? Data {
            audioImage = UIImage(data: audioImageData)
        }

        /// Extracts the `duration` from the selected audio file. If the file has `invalid duration`,  return `nil`.
        guard duration.isFinite && duration > 0 else {
            print("Error in extracting duration")
            return nil
        }

        /// If `all cases` have been `passed successfully`, it means a valid `AudioModel` has been created, which can now be returned.
        return AudioModel(title: String(title), artist: artist, duration: duration, url: url, image: audioImage ?? nil)

    }
}

